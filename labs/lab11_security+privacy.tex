\documentclass[10pt, a4paper, twosize]{article}
%\documentclass[12pt, a4paper, twoside]{book}

\usepackage{helvet}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage[
	a4paper,
	outer=2cm,
	inner=4cm,
	top=2cm,
	bottom=2cm
]{geometry}
\usepackage{float}
\usepackage{tabularx}
\usepackage[disable]{todonotes}
\usepackage{color, soul}
\usepackage{amsmath}
\usepackage{algorithmicx}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{framed}
\usepackage{subcaption}
\usepackage{titlepic}
\usepackage{fancyhdr}
\usepackage[simplified]{styles/pgf-umlcd}
\usepackage{shorttoc}
\usepackage{url}
\usepackage{paralist}

\definecolor{grey}{rgb}{0.9, 0.9, 0.9}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{dkred}{rgb}{0.6,0,0.0}

\lstdefinestyle{DOS}
{
    backgroundcolor=\color{black},
    basicstyle=\scriptsize\color{white}\ttfamily,
    stringstyle=\color{white},
    keywords={}
}

\lstdefinestyle{makefile}
{
    numberblanklines=false,
    language=make,
    tabsize=4,
    keywordstyle=\color{red},
    identifierstyle= %plain identifiers for make
}

\lstset{
  language=Java,                % the language of the code
  basicstyle=\footnotesize\ttfamily,
  numbers=left,                   % where to put the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{dkred},         % string literal style
  columns=fixed,
  extendedchars=true,
  frame=single,
}

%\renewcommand{\chaptername}{Topic}

% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\pagestyle{fancy}
\fancyhf{}
\fancyhead[RO, LE]{\small \rightmark}
\fancyfoot[RO, LE]{\small \thepage}

\begin{document}

%\frontmatter

\begin{titlepage}
\vspace*{5cm}
\begin{center}
\includegraphics[width=.5\textwidth]{images/EdNapUniLogoCMYK}~\\[1cm]

\textsc{\Large Edinburgh Napier University}\\[1.5cm]

\textsc{\LARGE \bfseries SET08101/SET08401 Web Tech}\\[0.5cm]

\hrulefill \\[0.4cm]
{\huge \bfseries Lab 11 - Security \& Privacy  \\[0.4cm] }
\hrulefill \\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\textbf{Dr Simon Wells} \\
\end{flushleft}
\end{minipage}

\vfill

\end{center}
\end{titlepage}

%\shorttoc{Overview}{0}

%\setcounter{tocdepth}{2}
%\cleardoublepage
%\tableofcontents
%\listoffigures
%\listofalgorithms
%\addtocontents{toc}{~\hfill\textbf{Page}\par}

%\mainmatter

%\input{sections/labs/04_ui}

\section*{Aims}
\paragraph{} In this final topic we shall address some issues associated with security and privacy. As each of these topics could be covered by an entire module in its own right we shall only be able to scratch the surface. We'll start by investigating some security practices associated with web development then look at what we need to know in terms of developing web sites that preserve privacy.

\paragraph{} At the end of the practical portion of this topic you will:

\begin{itemize}
\item Have considered the three core aspects of security, namely Authentication, Authorisation, and Auditing, that make up a triple-A security architecure
\item Have explored tactics for implementing aspects of triply-A security within a Node.JS application
\item have studied the ICO guidance on GDPR
\item have audited your mini-projects in line with GDPR guidance on privacy 
\end{itemize}

\clearpage
\part{Security}
\paragraph{} There is no such thing as a secure computer system. There are only systems that are more difficult to access. For example, a computer that sits in a securely locked room, without network access of any kind is reasonably secure. It's even more secure if the machine is kept switched off. However, it is debatable whether this is a useful computer system. It's definitely not a good Web system though if it isn't connected to the Internet and cannot be accessed.

\paragraph{} If your data is publicly published and you don't have any private data on your site then, for the most part, your security issues are practical and concerned with ensuring that your server stays running, is accessible by your users, and is not compromised by any third party. This is, essentially, an issue for your server adminstrator to handle and will, as a rule, requre adherence to established security practises for keeping a server secure.

\paragraph{} Things start to become more complicated when we have systems that are backed by datastores, record data about, created by, and belonging to users, and which supply functionality to those users. Private data becomes something that must be secured, and ensuring that users can only access data that they are \emph{authorised} to access, and that the user is \emph{authenticated}, we know who they are, and ensuring that we have a mechanism to \emph{audit} access so we know what they did, is increasingly important.

\section*{Activities}
\subsection*{Authentication}
\paragraph{} How are you storing user passwords? Gone are the days when a plain text file of user passwords was acceptable\footnote{I'm not sure it ever was, but organisations keep getting caught out}. Try entering some of your email addresses into the ``Have I been pwned'' site\footnote{https://haveibeenpwned.com/} which collects inforamtion about login credentials from site breaches. My own email address appears in two breaches as can be seen here:

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth]{images/pwned}
\caption{}
\label{fig:pwned}
\end{figure}

\paragraph{} There is not much we can do after the fact, other than be thankful that we use strong, random, and long passwords that are unique to every site we sign up with\footnote{We do, don't we? If you don't then this is a good first task. You cannot rely on Web developer to get everything right all the time.}


\paragraph{} If the passwords in your web-apps aren't stored securely then you are storing up problems for the future, not only professionally, but also legally. Minimally, your users passwords should be secured using a password hashing scheme. When a user supplies a password to your site, for example, when creating new account or when signing in, the plaintext password, the one that they typed, must be manipulated, using cryptography, into a ciphertext, an encrypted form. It is the encrypted form that we store, and never, \emph{NEVER} the plaintext form. When a user supplies their password, for example, at login, we pass the password through our encryption function and compare the new encrypted password against the stored encrypted password. If they match then the user supplied a good password, and if they don't then we can reject the login. This is based on the idea that a hash function can take a text in one form (the plaintext) and map it uniquely to another form (the ciphertext). The mapping however is designed to only work in one direction, so if we only have the ciphertext then there is no practical way to recover the original plaintext. Furthermore, for password hashing, because we want to avoid a rainbow table attack, we also want our hashing function to work as slowly as practically possible. Therefore password hashing functions are fairly special amongst the panoply of cryptographic hashing functions.

\paragraph{} Node has a crypto module that we can use to access various cryptographic facilities. We can use the bcrypt node library to hash passwords. First, use NPM to install bcrypt, e.g.

\begin{lstlisting}[style=DOS]
    npm install --save bcrypt
\end{lstlisting}


\paragraph{} Now let's try that out with a quick sript (bcrypt\_demo.js:
\begin{lstlisting}
const bcrypt = require('bcrypt');

var userpw = 'super secret password';
var badpass = 'bad password';
let hash = bcrypt.hashSync(userpw, 10);
console.log("Hashed password: " + hash);

console.log("Using password: '"+badpass+"' we get:");
if(bcrypt.compareSync(badpass, hash))
{
    console.log("match");
}
else
{
    console.log("unmatch");
}

console.log("Using password: '"+userpw+"' we get:");
if(bcrypt.compareSync(userpw, hash))
{
    console.log("match");
}
else
{
    console.log("unmatch");
}

\end{lstlisting}
\paragraph{} Much of this is just some gubbins to help us see what is happening when we run the script. The important part is that we have a password, userpw, which stores the users supplied password. In the real world we would pass this straight into the hash function and forget it at the earliest opportunity. We done want to ever store userpw. We've also got a test bad password, in the badpass variable, for testing purposes. This is just a string that doesn't match out real password. We then compute the hash of userpw using the synchronous version ofthe bcrypt hash function and we store this in hash. In reality we would probably store hash in our database or a user record of some sort waiting for the user to log in.

\paragraph{} We then have to simulations of logging in and comparing the supplied password, which might come from a login forms password field, to our hashed password. We use the synchronised version of the bcrypt compare function to do this and then print a message depending upon whether the hash of the supplied password matches the hash of the stored password.

\paragraph{} Hashing can be compute intensive and could conceivably block your apps thread of execution so bcrypt also provide asynchronous versions, e.g.

\begin{lstlisting}
bcrypt.hash('myPassword', 10, function(err, hash) {    });
\end{lstlisting}
\paragraph{} for hashing, and 

\begin{lstlisting}
bcrypt.compare('somePassword', hash, function(err, res)
{
    if(res)
    {
       // Passwords match
    } 
    else
    {
       // Passwords don't match
    } 
});
\end{lstlisting}
\paragraph{} for comparing a password to the stored hash.

\paragraph{} There is much more to authentication that just safely storing passwords, but it's a place to start.

\subsection*{Authorisation}
\paragraph{} Passwords and hashing are a rabbit hole that it is fun to get sucked down, but there is too much for this lab, and we have other thing to move on to, like securing routes. The basic idea is that an authenticated user should only be able to access routes that they are authorised for. This means that at the minimum we need three kinds of route, those that are public, those that are private and available to the current logged in user, and those that are private and not available to the current logged in user.

\paragraph{} Restricting access to a given route, or set of routes, is straightforward using express. Really it is straightforward in any implementation where you can follow a basic pattern:

\begin{enumerate}
\item User supplies credentials and authenticates themself
\item Successul authentication yields a cookie, or some other token, that the user can supply to the server when they make a request
\item Before returning a page to a user, the server must check the supplied credentials or token and determine whether the user is allowed (authorised) to access the page
\item If the user is authorised then the page they requested is generated and returned to them
\item If the user isn't authorised then the user is redirect to another page.
\end{enumerate}

\paragraph{} We can see an implementation of part of this in the following simple express demo.
\begin{lstlisting}
const express = require('express')
const app = express()
const port = 3000

function isAuthenticated(req, res, next)
{
    let auth = true;

    if(auth)
        return next();

    res.redirect('/');
}

app.get('/', (req, res) => res.send('Hello World!'));
app.get('/secret', isAuthenticated, function(req, res) { res.send('daka daka daka');});

app.listen(port, () => console.log(`Example app listening on port ${port}!`))
\end{lstlisting}
\paragraph{} Notice that we have a function, isAuthenticated(), whose sole purpose is to check whether the user is logged in. We've set this value to true right now, and you should experiment with the situation if the value is set to false. In a real app this value would be determined based upon the supplied user credentials but this is meant to be the simplest possible example of restricting a route. The isAuthenticated() function is an example of an express middlewhere function and is called when the /secret route is requested. Middleware functions have access to both the request and response objects and can either decide to allow access to the requested route, using the next() function, or to redirect the user elsewhere, in this case to the root route.

\paragraph{} Experiment with this program and add some extra routes, some protected and some not. Try to implement a login feature so that we can avoid the hardcoded value. You might need to make a simple log in page to enable your user to supply the credentials, however the values for them could be hardcoded at this point. Make sure to use password hashing though...

\subsection*{Logging}
\paragraph{} Making sure that there is some record of what your site is doing is important. It can enable you to fix bugs, but also to detect when someone is using your site improperly. When we looked at NGinX earlier, there is built in logging functionality by default but then, the case for logging a static site is quite straightforward. Logging from a dynamic site is more complex, for every thing that you site does, you must decide whether to log it or not. Getting the right balance is difficult and comes with experience and even then is more art than science. On the one hand we want to log as much as possible so as not to miss something important, but on the other hand we don't want to waste storage on logs that we may never need\footnote{Some people have also raised questions regarding private data, in the GDPR sense, and server logs}.

\paragraph{} One simple way to log is to use the console.log, console.info, console.warn, and console.error functions as follows (logtest.js):

\paragraph{}
\begin{lstlisting}
const express = require('express')
const app = express()
const port = 3000

function isAuthenticated(req, res, next)
{
    let auth = false;

    if(auth)
    {
        console.log('authorised:'+auth);
        return next();
    }

    console.error('authorised:'+auth);
    res.redirect('/');
}

app.get('/', (req, res) => res.send('Hello World!'));
app.get('/secret', isAuthenticated, function(req, res) { res.send('daka daka daka');});

app.listen(port, () => console.log(`Example app listening on port ${port}!`))
\end{lstlisting}
\paragraph{} An alternative approach is to use a more full featured asynchronous logging library, such as Morgan, or Winston.

\paragraph{} Use NPM to install Winston
\begin{lstlisting}
npm install winston
\end{lstlisting}

\paragraph{} Now we can enhance our authentication and authorisation example with some Winston logging (winstontest.js):
\begin{lstlisting}
'use strict';
const express = require('express');
const app = express()
const port = 3000

const winston = require('winston');
const { createLogger, format, transports } = require('winston');
const logger = winston.createLogger({
    level: 'debug',
    format: format.combine(
            format.timestamp(),
            format.json()
        ),
    transports: [new transports.File({
        filename: 'app.log',
        'timestamp': true
    })]
});

function isAuthenticated(req, res, next)
{
    let auth = false;

    if(auth)
    {
        logger.log('info', 'auth')
        return next();
    }

    logger.warn('not auth')
    res.redirect('/');
}

app.get('/', (req, res) => res.send('Hello World!'));
app.get('/secret', isAuthenticated, function(req, res) { res.send('daka daka daka');});

app.listen(port, () => console.log(`Example app listening on port ${port}!`))
\end{lstlisting}
\paragraph{} Notice that we've had to require the winston library and create some variables. We've then initiated a logger object with some values, one of which is to log to a file called app.log and another is to use JSON format and add a timestamp to log lines. However there are many more settings that Winston supports so it is best to delve into the documentation to get the exact logging setup that you want. We then use our logger by calling it and passing a message.









\clearpage
\part{Privacy}
\section*{Activities}
\subsection*{GDPR}
\paragraph{} All web developers should, nowadays, have some familiarlarity with the General Data Protection Regulation (GDPR) which came into force in 2018. The best place, at least in the UK, to find out accurate information about the GDPR is via the Information Commisioner's Office (ICO) guide\footnote{\url{https://ico.org.uk/for-organisations/guide-to-data-protection/guide-to-the-general-data-protection-regulation-gdpr/}}. Visit the site and work through it. I'd like to say that there are important parts to read and others that can be skipped, but unfortunately every part of the GDPR is important not only for safe guarding our user's privacy but also for ensuring that we are in alignment with the law. As you read through the GDPR consider the following two aspects:

\begin{enumerate}
\item Any points that you think are unambiguous or underspecified?
\item Any requirement of GDPR compliance that you think could be checkable, for instance, in your own web sites.
\end{enumerate}

\subsection*{Privacy Audit}
\paragraph{} Note that there are many forms of privacy, not just a single thing called `private data'. For example, consider the following categories of privacy:

\begin{enumerate}
\item Privacy of person
\item Privacy of behavior and action
\item Privacy of communication
\item Privacy of data and image (information)
\item Privacy of thoughts and feelings
\item Privacy of location and space (territorial)
\item Privacy of association
\end{enumerate}
\paragraph{} Try to come up with examples of each category of privacy. The aim of this exercise is to start focussing our attention on the range of ways that data held in, or collected, by our sites, can be problematic.

\paragraph{} Unfortunately privacy auditing is an effort intensive human activity at present. For this part of the lab you will select your most advanced mini-projects and consider the data that they store, whether that data is in compliance with GDPR, and what you might have to do to bring your site into line with GDPR. Also consider any general principles of privacy aware design, for example, have you considered the following when designing and developing your site, and is the choice, when a choice has to be made, documented?

\begin{enumerate}
\item Choice \& consent
\item Legitimate purpose specification limitations on use
\item The lifecycle of personal and sensitive information\item 
\item Accuracry and quality
\item Openness and transparency
\item Individual participation
\item Accountability
\item Security safeguards
\item Monitoring, measuring, and reporting
\item Preventing harm
\item Third-party and vendor management
\item Breach management
\item Security and privacy by design
\item Free flow of information and legitimate restriction
\end{enumerate}

\paragraph{} Note that many of these principles are not purely technical. Many actually focus more on having a documented plan that can be followed in the event of a problem, and thinking before doing, e.g. consider the data that you are collecting and actively justifying that collection.

\begin{enumerate}
\item Is consent obtained when personally identifiable information is obtained from individuals?
\item Do you have clear guidelines in place to ensure appropriate use of and retention of data throughout your organisation?
\item Does your record manangement guideline describe the strategy and procedures for maintenance, retention, and destruction of data?
\item Are the purpose and scope of data collection and the associated record management process clearly defined?
\item Are roles and responsibilities clearly defined and recorded for those with roles and responsibilities in data governance related to privacy, confidentiality, and compliance with regulations?
\item Are appropriate data encryption stadards in place for data at rest?
\item Is appropriate data awarenes training conducted for employees?
\item Is awareness accounted for and are key metrics identified to determine conformance and compliance with training?
\item Is there a breach escalation plan for reacting to breaches that affect personally identifiable information?
\item Are there appropriate tools and means in place to appropriately deidentify data when it is used within the organisation?
\item Do policies take into account region or country specific requirements that are necessary for operating legally in those regions or countries?
\end{enumerate}

\paragraph{} Finally, consider the kinds of things you would have to record in a privacy policy to ensure that you had documented your approach to managing user data.

\clearpage
\part{Challenges}
\paragraph{} Apply what we've looked at in this topic to your earlier mini-projects where appropriate. This should help you to focus on the data that each project has collected and whether any can be considered sensitive.

\paragraph{} Search for the most egregious examples of personal information collection that you can find online. You might want to look at sign-up processes of social media sites. Look at the privacy policies, particularly those that are click through and only show details after a link is followed. Consider whether these are in line with the privacy practises we've investigated earlier. Is the language in a form that is understandable? Are the policies made available and easy to find? Are the policies of a length that is reasonable for a person to be able to read, understand, and agree to them?

\paragraph{} Becoming a good web developer is a function of practice, so your mini-projects are a good opportunity to perform some deliberate and considered practise of your skills in a context that you can own. Except for those of you who will continue to build sites for fun, many of you will now only get real practise during active development projects, but these, unfortunately, often don't provide opportunities to learn. So, consider completing any of the mini-projects that you've started and haven't yet gotten to the point where you would describe it as done.


\end{document}

%\begin{framed}
%\end{framed}


%\begin{lstlisting}
%\end{lstlisting}
